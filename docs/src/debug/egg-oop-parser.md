---
title: "Adding OOP to the Egg Parser"
key: egg-oop-parser
published: true
date: 2022/04/12
delivery: "2022/04/28"
order: 13
layout: Practica
sidebar: auto
template: "https://github.com/ULL-ESIT-PL-2122/egg-oop-parser-template"
rubrica: 
  - Added properties with brackets
  - Added dot selector for objects 
  - Added Array literal notation 
  - Added Object literal notation
  - The lexer generator module has being extended to support lexical transformations
  - Added token transformation replace/WORD COLON/STRING COMMA/g
  - Correctly solves lexical ambiguity for numbers <code>4.+(5).+(3.2)</code>
  - Multiple Object indexation supported 
  - Currying works with methods <code>4&#91;\"+\", 5&#93;(3)</code>
  - Contiene suficientes tests
  - Se provee un workflow sencillo para convertir r√°pidamente un ejemplo operativo en un test 
  - Estudio de covering
  - Se ha hecho CI con GitHub Actions
  - M√≥dulo bien documentado 
  - Informe hecho con Vuepress desplegado
  - Se ha publicado como m√≥dulo y se ha hecho un buen uso del versionado sem√°ntico en la evoluci√≥n del m√≥dulo
---

# {{$frontmatter.title }}

<!-- Only the + implemented as method of numbers. Need to implemetn the rest ... -->

## Introducci√≥n

En esta pr√°ctica, queremos aumentar la expresividad de nuestro lenguaje. 

El siguiente ejemplo muestra algunas de las extensiones que introducimos en esta pr√°ctica:

```ruby
‚ûú  egg-oop-parser-solution git:(master) cat examples/object-colon-selector.egg 
do (
  def(x, { # object literals!
    c: [1, 2, 3], # array literals!
    gc:  fun(
           element(self, "c") # old way works
         ), 
    sc:  fun(value, # look at the left side of the assignment!
           =(self.c[0], value)
         ),
    inc: fun( 
           =(self.c[0], +(self.c[0], 1)) 
         ) 
  }),
  print(x),
  print(x.gc()),    # [1, 2, 3]
  x.sc(4),
  print(x.gc()),    # [4,2,3]
  x.inc(),
  print(x.gc()),    # [5,2,3]
  print(x.c.pop()), # 3
  print(x.c)        # [5,2]
)
```

Observe algunas de las funcionalidades introducidas:

* Se han a√±adido las llaves `{}` para referirse a objetos literales: `def(x, { ... })`
* Observe la aparici√≥n del token *colon* `:` para separar en un objeto el nombre del atributo del valor
* Se han a√±adido los corchetes `[]` para referirse a *array literals* `[1, 2, 3]`
* Es posible acceder a las propiedades de un objeto usando el punto como en `x.c`
* `self` denota al objeto. Como `this` en JS
* Es posible acceder a las propiedades de un objeto usando corchetes como en `self.c[0]`


## Egg Virtual Machine with OOP extensions 

During the development of this lab, you can execute the ASTs generated by your parser using one of the interpreters in this release:

* [Egg Virtual Machine with OOP extensions for Windows/Linux/Mac OS](https://github.com/crguezl/oop-evm-releases/releases/tag/v1.0.0)

download the version you need for the development of this lab, make a symbolic link to have it at hand:

```
‚úó ln -s ~/campus-virtual/shared/egg/oop-evm-releases/evm-2122-macos ./evm
``` 

and try with some example:

```js
‚úó ./evm examples/object-colon-selector.json 
{"c":[1,2,3]}
[1,2,3]
[4,2,3]
[5,2,3]
3
[5,2]
```

## Multiple Attribute Indexation

You can make multiple indexation of an object other than a function so that 
`a[0,2]` means `a[0][2]`:

```js
‚ûú  egg-oop-parser-solution git:(master) ‚úó cat examples/multiple-properties.egg 
do(
    def(a, [[4,5,6], 1,2,3]),
    def(b, a[0,2]),
    print(b) # 6
)%                                                                                                                   
‚ûú  egg-oop-parser-solution git:(master) ‚úó bin/eggc.js examples/multiple-properties.egg
‚ûú  egg-oop-parser-solution git:(master) ‚úó npx evm examples/multiple-properties.json   
6
```

Same for objects (other than a function) `a["p", "q", "r"]` means `a.p.q.r` or `a["p"]["q"]["r"]`:

```js
‚ûú  egg-oop-parser-solution git:(master) ‚úó cat  examples/multiple-properties-object-dot.egg
do(
    def(a, { p : { q : { r : 1 } } }),
    def(b, a["p", "q", "r"]),
    print(b) # 1
)
‚ûú  egg-oop-parser-solution git:(master) ‚úó bin/eggc.js examples/multiple-properties-object-dot.egg
‚ûú  egg-oop-parser-solution git:(master) ‚úó npx evm examples/multiple-properties-object-dot.json   
1
```

## Currying in Egg

When multiple arguments are used to index a function is interpreted as [currying the function](https://en.wikipedia.org/wiki/Currying). For instance:

```js
‚ûú  egg-oop-parser-solution git:(master) ‚úó cat examples/curry-method.egg 
do (
  print(4["+", 5](3)), # 4["+"](5, 3) # 12
  print(4["*", 5](3)), # 4["*"](5, 3) # 60
  print(6["/", 2](3)), # 6["/"](2, 3) # 1
  print(6["-", 2](3))  # 6["/"](2, 3) # 1
)
```

Execution:

```
‚ûú  egg-oop-parser-solution git:(master) ‚úó npx evm examples/curry-method.json      
12
60
1
1
```

this is a *design decision* that is somewhat inconsistent with the decision take for other types of objects 
ü§®

## The Extended ASTs

Consider the following Egg program:

```
‚ûú  egg-oop-parser-solution git:(master) ‚úó cat examples/dot-num.egg                         
print(4.3.toFixed(2))
```

We want to generate an AST like this one:

```js{9}
‚ûú  egg-oop-parser-solution git:(master) ‚úó cat examples/dot-num.json 
{
  "type": "apply",
  "operator": { "type": "word", "name": "print" },
  "args": [
    {
      "type": "apply",
      "operator": {
        "type": "property",
        "operator": { "type": "value", "value": 4.3, },
        "args": [ { "type": "value", "value": "toFixed", }  ]
      },
      "args": [ { "type": "value", "value": 2, } ]
    }
  ]
}
```

## The Dot Ambiguity: Property dot or Mantissa dot?

Al introducir el *dot* para seleccionar la propiedad del objeto se produce una ambiguedad con el punto en los flotantes:

```js
‚ûú  egg-oop-parser-solution git:(master) ‚úó cat test/examples/dot-num.egg 
print(4.3.toFixed(2))
```

Se propone que la ambiguedad se resuelva dando prioridad a la interpretaci√≥n como *punto de n√∫mero* si el punto va seguido de un d√≠gito, en otro caso estamos accediendo a la propiedad del n√∫mero:

```
‚ûú  egg-oop-parser-solution git:(master) bin/eggc.js test/examples/dot-num.egg 
‚ûú  egg-oop-parser-solution git:(master) ‚úó npx evm test/examples/dot-num.json  
4.30
```

Esto es diferente de lo que hace JS:

```js
‚ûú  pl2122apuntes git:(main) node
Welcome to Node.js v16.0.0.
Type ".help" for more information.
> 4.toFixed(2)
4.toFixed(2)
^^

Uncaught SyntaxError: Invalid or unexpected token
> (4).toFixed(2)
'4.00'
```

## Adding Lexical Transformations to our Lexer Generator Module

Para facilitar la labor de hacer esta pr√°ctica es conveniente que volvamos al m√≥dulo [lexer-generator](/practicas/lexer-generator) y modifiquemos un poco su API dotandolo de la capacidad de a√±adir transformaciones l√©xicas.

Para ello la funci√≥n `nearleyLexer` recibir√° ahora un par√°metro adicional de un objeto con opciones.

```js
let lexer = nearleyLexer(tokens, { transform: transformerFun});
```

La √∫nica opci√≥n que vamos a implementar es `transform`. Que aplica la funci√≥n `transformerFun` a cada uno de los `tokens` del objeto lexer generado por `nearleyLexer`. En nuestro caso queremos transformar las secuencias `WORD COLON` en  secuencias `STRING COMMA` de manera que `x: 4` sea equivalente a escribir `"x", 4"`

```js
function colonTransformer(tokens) {
  // ... s/WORD COLON/STRING COMMA/g
 return tokens;
}
```

 Este es un ejemplo de uso de la nueva funcionalidad:


To achieve the goal we have to modify the `reset` method of our nearley compatible object:

```js
const nearleyLexer = function(regexps, options) {
  const {validTokens, lexer} = buildLexer(regexps);
  validTokens.set("EOF");
  return {
    // ...
    reset: function(data, info) { 
      // ... Work here!
    },
 // ...
}
```

## Grammar 


The following grammar is a NearleyJS non ambiguous grammar that allows the requested features and extends the previous Egg grammar we intoduced in lab [egg-parser](/practicas/egg-parser.html):

```js
program -> expression %EOF 
expression -> 
      %STRING  optProperties
    | %NUMBER  optProperties
    | %WORD applies
    | bracketExp
    | curlyExp

applies -> calls
    | properties
    | null
calls ->  parenExp applies
properties ->  bracketExp  applies
    | selector applies            

parenExp   -> "("  commaExp ")"
bracketExp -> "["  commaExp "]"
curlyExp   -> "{"  commaExp "}"

selector   ->  "." %WORD

commaExp -> null
   | expression ("," expression

optProperties -> null
   | properties
```

## Syntax Diagram /Railroad Diagram

<egg-oop-syntax-diagram></egg-oop-syntax-diagram>


## Resources

* [Egg Virtual Machine with OOP extensions for Windows/Linux/Mac OS](https://github.com/crguezl/oop-evm-releases/releases/tag/v1.0.0)
* [Eloquent JS: Chapter 11. Project: A Programming Language](http://eloquentjavascript.net/11_language.html)
* [V√≠deo *Programando un bucle REPL para el lenguaje Egg*](https://youtu.be/5gIlt6r29lw)
* El m√≥dulo [@ull-esit-pl/example2test](https://www.npmjs.com/package/@ull-esit-pl/example2test)


